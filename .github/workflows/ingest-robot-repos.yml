name: Ingest robot repo submissions

on:
  issues:
    types: [opened, edited, labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: Issue number to ingest
        required: true

concurrency:
  group: ingest-robot-repos
  cancel-in-progress: false

jobs:
  ingest:
    if: github.event_name == 'workflow_dispatch' || contains(join(github.event.issue.labels.*.name, ','), 'robot-repo')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Update robots.json from issue
        id: ingest
        uses: actions/github-script@v7
        with:
          script: |
            const inputIssueNumber = context.payload.inputs?.issue_number;
            const issueNumber = context.payload.issue?.number || (inputIssueNumber ? Number(inputIssueNumber) : null);
            if (!issueNumber) {
              core.setFailed("Missing issue number.");
              return;
            }

            const issue =
              context.payload.issue ||
              (
                await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                })
              ).data;
            const body = issue.body || "";

            const clean = (value) => {
              if (!value) return "";
              const trimmed = value.trim();
              if (!trimmed || trimmed.toLowerCase() === "no response" || trimmed === "_No response_") {
                return "";
              }
              return trimmed;
            };

            const parseIssueFields = (text) => {
              const fields = {};
              const regex = /^###\s+(.+)\n+([\s\S]*?)(?=^###\s+|\Z)/gm;
              let match;
              while ((match = regex.exec(text)) !== null) {
                fields[match[1].trim()] = clean(match[2]);
              }
              return fields;
            };

            const parseRepoUrl = (url) => {
              if (!url) return { error: "missing" };
              let normalized = url.trim();
              if (!normalized) return { error: "missing" };

              const mdMatch = normalized.match(/\((https?:\/\/github\.com\/[^)]+)\)/);
              if (mdMatch) {
                normalized = mdMatch[1];
              }

              normalized = normalized.replace(/\.git$/i, "").replace(/\/+$/, "");

              if (normalized.startsWith("github.com/") || normalized.startsWith("www.github.com/")) {
                normalized = `https://${normalized.replace(/^www\./, "")}`;
              }

              const sshMatch = normalized.match(/^git@github\.com:([^/]+)\/(.+?)(?:\.git)?$/i);
              if (sshMatch) {
                return { owner: sshMatch[1], repo: sshMatch[2].replace(/\.git$/i, ""), path: "" };
              }

              if (!normalized.includes("github.com")) {
                const parts = normalized.split("/").filter(Boolean);
                if (parts.length === 1) {
                  return { error: "missing-repo", owner: parts[0] };
                }
                if (parts.length >= 2) {
                  return { owner: parts[0], repo: parts[1], path: parts.slice(2).join("/") || "" };
                }
                return { error: "invalid" };
              }

              try {
                const urlObj = new URL(normalized);
                const parts = urlObj.pathname.split("/").filter(Boolean);
                if (parts.length === 1) {
                  return { error: "missing-repo", owner: parts[0] };
                }
                if (parts.length < 2) return { error: "invalid" };
                const owner = parts[0];
                const repo = parts[1].replace(/\.git$/i, "");
                let path = "";
                if (parts.length > 2 && parts[2] === "tree") {
                  if (parts.length > 4) {
                    path = parts.slice(4).join("/");
                  }
                } else if (parts.length > 2) {
                  path = parts.slice(2).join("/");
                }
                return { owner, repo, path };
              } catch {
                return { error: "invalid" };
              }
            };

            const parseLines = (value) =>
              value
                .split(/\r?\n/)
                .map((line) => line.trim())
                .filter(Boolean);

            const parseTags = (value) => {
              if (!value) return [];
              return value
                .split(/[,\n]/)
                .map((tag) => tag.trim())
                .filter(Boolean);
            };

            const parseRobotMapping = (value) => {
              if (!value) return [];
              const lines = parseLines(value);
              const robots = [];
              for (const line of lines) {
                let name = "";
                let file = "";
                const separators = [" — ", " – ", " - ", " —", " –", " -"];
                let parts = null;
                for (const sep of separators) {
                  if (line.includes(sep)) {
                    parts = line.split(sep);
                    break;
                  }
                }
                if (!parts && line.includes(":")) {
                  parts = line.split(":");
                }
                if (parts && parts.length >= 2) {
                  name = parts[0].trim();
                  file = parts.slice(1).join("-").trim();
                } else {
                  name = line.trim();
                }
                if (!name && !file) continue;
                if (file) {
                  const fileName = file.split("/").pop() || file;
                  robots.push({ name: name || fileName.replace(/\.urdf$/i, ""), file: fileName });
                } else {
                  robots.push({ name });
                }
              }
              return robots;
            };

            const fields = parseIssueFields(body);
            let repoUrl = clean(fields["GitHub repo URL"]);
            if (!repoUrl) {
              const match = body.match(/https?:\/\/github\.com\/[A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+(?:\/[^\s\)]*)?/);
              if (match) {
                repoUrl = match[0];
              }
            }
            if (!repoUrl) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: "Auto-ingest: missing GitHub repo URL.",
              });
              return;
            }

            const repoInfo = parseRepoUrl(repoUrl);
            if (!repoInfo || repoInfo.error) {
              const errorMessage =
                repoInfo && repoInfo.error === "missing-repo"
                  ? `Auto-ingest: please provide a full GitHub repo URL (owner/repo). I received an org URL: ${repoUrl}\nExample: https://github.com/TheRobotStudio/SO-ARM100`
                  : `Auto-ingest: couldn't parse repo URL: ${repoUrl}`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: errorMessage,
              });
              return;
            }

            const { owner, repo, path } = repoInfo;
            let defaultBranch = "main";
            try {
              const repoData = await github.rest.repos.get({ owner, repo });
              defaultBranch = repoData.data.default_branch || "main";
            } catch (error) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `Auto-ingest: couldn't access ${owner}/${repo}.`,
              });
              return;
            }

            const fetchTree = async () => {
              const treeRef = path ? `${defaultBranch}:${path}` : defaultBranch;
              try {
                const tree = await github.rest.git.getTree({
                  owner,
                  repo,
                  tree_sha: treeRef,
                  recursive: "1",
                });
                return tree.data.tree || [];
              } catch {
                if (!path) return [];
                const rootTree = await github.rest.git.getTree({
                  owner,
                  repo,
                  tree_sha: defaultBranch,
                  recursive: "1",
                });
                return (rootTree.data.tree || []).filter((entry) => entry.path.startsWith(path));
              }
            };

            const tree = await fetchTree();
            const urdfFiles = tree
              .filter((entry) => entry.type === "blob" && entry.path.toLowerCase().endsWith(".urdf"))
              .map((entry) => entry.path);

            const mapping = parseRobotMapping(clean(fields["Robot mapping (optional)"]));
            const robots =
              mapping.length > 0
                ? mapping
                : urdfFiles.map((filePath) => {
                    const fileName = filePath.split("/").pop() || filePath;
                    return { name: fileName.replace(/\.urdf$/i, ""), file: fileName };
                  });

            const entry = {
              repo: `https://github.com/${owner}/${repo}`,
              repoKey: `${owner}/${repo}`.toLowerCase(),
              path: path || undefined,
              org: clean(fields["Author / Company / Lab (optional)"]),
              summary: clean(fields["Short summary"]),
              demo: clean(fields["Demo URL (optional)"]),
              tags: parseTags(clean(fields["Tags (optional)"])),
              robots: robots.length ? robots : undefined,
              hfDatasets: parseLines(clean(fields["Hugging Face datasets (one per line, optional)"])),
              authorWebsite: clean(fields["Author website (optional)"]),
              authorX: clean(fields["Author X/Twitter (optional)"]),
              authorLinkedin: clean(fields["Author LinkedIn (optional)"]),
              authorGithub: clean(fields["Author GitHub (optional)"]),
              contact: clean(fields["Contact (optional)"]),
              extra: clean(fields["Extra links or notes (optional)"]),
              updatedAt: new Date().toISOString(),
            };

            const normalizeRepoKey = (value) =>
              value
                ? value
                    .replace(/^https?:\/\/github\.com\//, "")
                    .split("/")
                    .slice(0, 2)
                    .join("/")
                    .toLowerCase()
                : "";

            const galleryOwner = context.repo.owner;
            const galleryRepo = context.repo.repo;
            const galleryInfo = await github.rest.repos.get({
              owner: galleryOwner,
              repo: galleryRepo,
            });
            const galleryDefaultBranch = galleryInfo.data.default_branch || "main";
            const branchName = `auto-ingest/issue-${issue.number}`;

            const ensureBranch = async () => {
              try {
                await github.rest.git.getRef({
                  owner: galleryOwner,
                  repo: galleryRepo,
                  ref: `heads/${branchName}`,
                });
              } catch (error) {
                if (error.status !== 404) throw error;
                const baseRef = await github.rest.git.getRef({
                  owner: galleryOwner,
                  repo: galleryRepo,
                  ref: `heads/${galleryDefaultBranch}`,
                });
                await github.rest.git.createRef({
                  owner: galleryOwner,
                  repo: galleryRepo,
                  ref: `refs/heads/${branchName}`,
                  sha: baseRef.data.object.sha,
                });
              }
            };

            await ensureBranch();

            let existing = [];
            let existingSha = null;
            try {
              const file = await github.rest.repos.getContent({
                owner: galleryOwner,
                repo: galleryRepo,
                path: "docs/robots.json",
                ref: branchName,
              });
              if (!Array.isArray(file.data) && file.data.content) {
                const decoded = Buffer.from(file.data.content, "base64").toString("utf8");
                existing = JSON.parse(decoded);
                existingSha = file.data.sha;
              }
            } catch {
              try {
                const file = await github.rest.repos.getContent({
                  owner: galleryOwner,
                  repo: galleryRepo,
                  path: "docs/robots.json",
                  ref: galleryDefaultBranch,
                });
                if (!Array.isArray(file.data) && file.data.content) {
                  const decoded = Buffer.from(file.data.content, "base64").toString("utf8");
                  existing = JSON.parse(decoded);
                  existingSha = file.data.sha;
                }
              } catch {
                existing = [];
              }
            }

            const repoKey = entry.repoKey;
            const idx = existing.findIndex((item) => normalizeRepoKey(item.repo || item.repoKey) === repoKey);
            if (idx >= 0) {
              const prev = existing[idx];
              const mergeValue = (value, fallback) => (value !== undefined && value !== "" ? value : fallback);
              const mergeArray = (value, fallback) => (Array.isArray(value) && value.length ? value : fallback);
              existing[idx] = {
                ...prev,
                repo: entry.repo || prev.repo,
                repoKey,
                path: mergeValue(entry.path, prev.path),
                org: mergeValue(entry.org, prev.org),
                summary: mergeValue(entry.summary, prev.summary),
                demo: mergeValue(entry.demo, prev.demo),
                tags: mergeArray(entry.tags, prev.tags),
                robots: mergeArray(entry.robots, prev.robots),
                hfDatasets: mergeArray(entry.hfDatasets, prev.hfDatasets),
                authorWebsite: mergeValue(entry.authorWebsite, prev.authorWebsite),
                authorX: mergeValue(entry.authorX, prev.authorX),
                authorLinkedin: mergeValue(entry.authorLinkedin, prev.authorLinkedin),
                authorGithub: mergeValue(entry.authorGithub, prev.authorGithub),
                contact: mergeValue(entry.contact, prev.contact),
                extra: mergeValue(entry.extra, prev.extra),
                updatedAt: entry.updatedAt,
              };
            } else {
              existing.unshift(entry);
            }

            const content = Buffer.from(JSON.stringify(existing, null, 2)).toString("base64");
            await github.rest.repos.createOrUpdateFileContents({
              owner: galleryOwner,
              repo: galleryRepo,
              path: "docs/robots.json",
              message: `Update robots.json from issue #${issue.number}`,
              content,
              sha: existingSha || undefined,
              branch: branchName,
            });

            const prs = await github.rest.pulls.list({
              owner: galleryOwner,
              repo: galleryRepo,
              state: "open",
              head: `${galleryOwner}:${branchName}`,
            });

            let prNumber = null;
            if (prs.data.length > 0) {
              prNumber = prs.data[0].number;
            } else {
              const pr = await github.rest.pulls.create({
                owner: galleryOwner,
                repo: galleryRepo,
                title: `Auto-ingest robot repo from issue #${issue.number}`,
                head: branchName,
                base: galleryDefaultBranch,
                body: `Closes #${issue.number}\n\nAuto-generated update from submission.`,
              });
              prNumber = pr.data.number;
            }

            await github.rest.issues.createComment({
              owner: galleryOwner,
              repo: galleryRepo,
              issue_number: issue.number,
              body: prNumber
                ? `Auto-ingest: opened PR #${prNumber}. Please merge to publish this entry.`
                : "Auto-ingest: updated branch, but couldn't open a PR. Please open one manually.",
            });

            core.setOutput("dispatch_payload", "");

      - name: Trigger URDF Studio sync
        if: ${{ steps.ingest.outputs.dispatch_payload != '' }}
        uses: actions/github-script@v7
        env:
          DISPATCH_PAYLOAD: ${{ steps.ingest.outputs.dispatch_payload }}
          DISPATCH_TOKEN: ${{ secrets.URDF_STUDIO_DISPATCH_TOKEN }}
        with:
          script: |
            if (!process.env.DISPATCH_TOKEN) {
              core.info("URDF_STUDIO_DISPATCH_TOKEN is not set. Skipping dispatch.");
              return;
            }
            const payload = JSON.parse(process.env.DISPATCH_PAYLOAD || "{}");
            const dispatchClient = getOctokit(process.env.DISPATCH_TOKEN);
            try {
              await dispatchClient.rest.repos.createDispatchEvent({
                owner: "amtellezfernandez",
                repo: "urdf-star-studio",
                event_type: "robot-repos-updated",
                client_payload: payload,
              });
            } catch (error) {
              core.warning(
                `URDF Studio dispatch failed: ${error.status || "unknown"} ${error.message || error}`
              );
              if (payload.issueNumber) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: payload.issueNumber,
                  body:
                    "Auto-ingest: saved to robots.json, but sync dispatch failed. " +
                    "Please verify URDF_STUDIO_DISPATCH_TOKEN has access to amtellezfernandez/urdf-star-studio.",
                });
              }
            }
